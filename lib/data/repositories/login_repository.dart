// lib/data/repositories/login_repository.dart
import 'package:drift/drift.dart'; // Import this for Value
import 'package:biochecksheet7_flutter/data/database/app_database.dart'; // Your database instance
import 'package:biochecksheet7_flutter/data/network/user_api_service.dart'; // Your network service for user
import 'package:biochecksheet7_flutter/data/models/logged_in_user.dart'; // Your user model
import 'package:biochecksheet7_flutter/data/models/login_result.dart'; // Your login result sealed class
import 'package:biochecksheet7_flutter/data/database/tables/user_table.dart'; // DbUser model generated by drift
import 'package:biochecksheet7_flutter/data/database/daos/user_dao.dart'; // Import UserDao here

/// Equivalent to LoginRepository.kt
/// Class that requests authentication and user information from the remote data source and
/// maintains an in-memory cache of login status and user credentials.
class LoginRepository {
  final UserApiService userApiService;
  final UserDao userDao; // No longer undefined after import

  LoggedInUser? _user;

  // Private constructor for singleton pattern (similar to LoginRepository in Kotlin)
  LoginRepository._internal({
    required this.userApiService,
    required this.userDao,
  });

  // Singleton instance
  static final LoginRepository _instance = LoginRepository._internal(
    userApiService: UserApiService(), // Instantiate your API service
    userDao: AppDatabase.instance.userDao, // Get DAO from your database instance
  );

  factory LoginRepository() {
    return _instance;
  }

  // Check if user is logged in (could be based on stored credentials or _user cache)
  bool get isLoggedIn => _user != null; // Or check local database/shared preferences

  // Logout function (similar to logout() in LoginRepository.kt)
  Future<void> logout() async {
    _user = null;
    // Clear user data from local database/shared preferences
    await userDao.deleteAllUsers(); // Clear local user data
    // TODO: Clear any stored session tokens if you implement them
  }

  // Login function (similar to login(username, password) in LoginRepository.kt)
  Future<LoginResult> login(String userCode, String password) async {
    try {
      // Attempt login via API service
      final apiResult = await userApiService.login(userCode, password);

      if (apiResult is LoginSuccess) {
        final loggedInUser = apiResult.loggedInUser;
        _user = loggedInUser; // Cache in memory

        // Save user data to local database for persistence
        // Convert LoggedInUser to UsersCompanion for insertion/update in drift
        final userEntry = UsersCompanion(
          userId: Value(loggedInUser.userId),
          userCode: Value(loggedInUser.userCode),
          password: Value(loggedInUser.password), // Store password carefully (hashed ideally)
          userName: Value(loggedInUser.displayName),
          status: const Value(1), // Assuming 1 means active/logged in
          lastSync: Value(DateTime.now().toIso8601String()),
        );
        await userDao.insertUser(userEntry); // Or update if exists

        return LoginSuccess(loggedInUser);
      } else if (apiResult is LoginFailed) {
        return LoginFailed(apiResult.errorMessage);
      } else if (apiResult is LoginError) {
        return LoginError(apiResult.exception);
      }
      return const LoginFailed("Unknown login error."); // Fallback
    } catch (e) {
      return LoginError(Exception("Login repository error: $e"));
    }
  }

  // You might also have a method to retrieve the current user from local storage
  Future<LoggedInUser?> getLoggedInUserFromLocal() async {
    // Assuming userCode is unique or you fetch the single logged-in user
    final users = await userDao.getAllUsers();
    if (users.isNotEmpty) {
      // Return the first user found or implement logic to get the correct one
      final dbUser = users.first;
      _user = LoggedInUser(
        userId: dbUser.userId ?? '',
        displayName: dbUser.userName ?? '',
        userCode: dbUser.userCode ?? '',
        password: dbUser.password ?? '',
      );
      return _user;
    }
    return null;
  }
}